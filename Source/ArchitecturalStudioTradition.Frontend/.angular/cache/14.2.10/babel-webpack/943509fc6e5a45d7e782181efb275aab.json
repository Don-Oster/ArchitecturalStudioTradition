{"ast":null,"code":"//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n\n/* tslint:disable */\n\n/* eslint-disable */\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport const API_BASE_URL = new InjectionToken('API_BASE_URL');\nexport let Service = /*#__PURE__*/(() => {\n  class Service {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n    }\n\n    headApiHeartbeat() {\n      let url_ = this.baseUrl + \"/api/heartbeat\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      let options_ = {\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({})\n      };\n      return this.http.request(\"head\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processHeadApiHeartbeat(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processHeadApiHeartbeat(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processHeadApiHeartbeat(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return _observableOf(null);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n\n  }\n\n  Service.ɵfac = function Service_Factory(t) {\n    return new (t || Service)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n  };\n\n  Service.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: Service,\n    factory: Service.ɵfac\n  });\n  return Service;\n})();\nexport let AccountsService = /*#__PURE__*/(() => {\n  class AccountsService {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n    }\n    /**\r\n     * @return Registers the new user\r\n     */\n\n\n    registerUser(command) {\n      let url_ = this.baseUrl + \"/api/accounts/register\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processRegisterUser(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processRegisterUser(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processRegisterUser(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      let _mappings = [];\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = RegistrationResponse.fromJS(resultData200, _mappings);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @return Logins the user\r\n     */\n\n\n    login(command) {\n      let url_ = this.baseUrl + \"/api/accounts/login\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processLogin(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processLogin(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processLogin(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      let _mappings = [];\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = AuthenticationResponse.fromJS(resultData200, _mappings);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @return Logins the user externally\r\n     */\n\n\n    externalLogin(command) {\n      let url_ = this.baseUrl + \"/api/accounts/external-login\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processExternalLogin(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processExternalLogin(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processExternalLogin(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      let _mappings = [];\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = AuthenticationResponse.fromJS(resultData200, _mappings);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @return Forgot password\r\n     */\n\n\n    forgotPassword(command) {\n      let url_ = this.baseUrl + \"/api/accounts/forgot-password\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processForgotPassword(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processForgotPassword(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processForgotPassword(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = resultData200 !== undefined ? resultData200 : null;\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @return Reset password\r\n     */\n\n\n    resetPassword(command) {\n      let url_ = this.baseUrl + \"/api/accounts/reset-password\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processResetPassword(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processResetPassword(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processResetPassword(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = resultData200 !== undefined ? resultData200 : null;\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @return Two-step verification\r\n     */\n\n\n    twoStepVerification(command) {\n      let url_ = this.baseUrl + \"/api/accounts/two-step-verification\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      const content_ = JSON.stringify(command);\n      let options_ = {\n        body: content_,\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processTwoStepVerification(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processTwoStepVerification(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processTwoStepVerification(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      let _mappings = [];\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = TokenResponse.fromJS(resultData200, _mappings);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n    /**\r\n     * @param email (optional)\r\n     * @param token (optional)\r\n     * @return Email confirmation\r\n     */\n\n\n    emailConfirmation(email, token) {\n      let url_ = this.baseUrl + \"/api/accounts/email-confirmation?\";\n      if (email !== undefined && email !== null) url_ += \"email=\" + encodeURIComponent(\"\" + email) + \"&\";\n      if (token !== undefined && token !== null) url_ += \"token=\" + encodeURIComponent(\"\" + token) + \"&\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      let options_ = {\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processEmailConfirmation(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processEmailConfirmation(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n\n    processEmailConfirmation(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = resultData200 !== undefined ? resultData200 : null;\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n\n      return _observableOf(null);\n    }\n\n  }\n\n  AccountsService.ɵfac = function AccountsService_Factory(t) {\n    return new (t || AccountsService)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n  };\n\n  AccountsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AccountsService,\n    factory: AccountsService.ɵfac\n  });\n  return AccountsService;\n})();\nexport class ResponseBase {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.appId = _data[\"appId\"];\n\n      if (Array.isArray(_data[\"errors\"])) {\n        this.errors = [];\n\n        for (let item of _data[\"errors\"]) this.errors.push(item);\n      }\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    throw new Error(\"The abstract class 'ResponseBase' cannot be instantiated.\");\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"appId\"] = this.appId;\n\n    if (Array.isArray(this.errors)) {\n      data[\"errors\"] = [];\n\n      for (let item of this.errors) data[\"errors\"].push(item);\n    }\n\n    return data;\n  }\n\n}\nexport class RegistrationResponse extends ResponseBase {\n  constructor(data) {\n    super(data);\n  }\n\n  init(_data, _mappings) {\n    super.init(_data);\n\n    if (_data) {\n      this.isSuccessful = _data[\"isSuccessful\"];\n\n      if (Array.isArray(_data[\"errors\"])) {\n        this.errors = [];\n\n        for (let item of _data[\"errors\"]) this.errors.push(item);\n      }\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, RegistrationResponse);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"isSuccessful\"] = this.isSuccessful;\n\n    if (Array.isArray(this.errors)) {\n      data[\"errors\"] = [];\n\n      for (let item of this.errors) data[\"errors\"].push(item);\n    }\n\n    super.toJSON(data);\n    return data;\n  }\n\n}\nexport class RegisterCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.email = _data[\"email\"];\n      this.password = _data[\"password\"];\n      this.clientUri = _data[\"clientUri\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, RegisterCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"email\"] = this.email;\n    data[\"password\"] = this.password;\n    data[\"clientUri\"] = this.clientUri;\n    return data;\n  }\n\n}\nexport class AuthenticationResponse extends ResponseBase {\n  constructor(data) {\n    super(data);\n  }\n\n  init(_data, _mappings) {\n    super.init(_data);\n\n    if (_data) {\n      this.isSuccessful = _data[\"isSuccessful\"];\n      this.errorMessage = _data[\"errorMessage\"];\n      this.token = _data[\"token\"];\n      this.is2StepVerificationRequired = _data[\"is2StepVerificationRequired\"];\n      this.isLockedOut = _data[\"isLockedOut\"];\n      this.provider = _data[\"provider\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, AuthenticationResponse);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"isSuccessful\"] = this.isSuccessful;\n    data[\"errorMessage\"] = this.errorMessage;\n    data[\"token\"] = this.token;\n    data[\"is2StepVerificationRequired\"] = this.is2StepVerificationRequired;\n    data[\"isLockedOut\"] = this.isLockedOut;\n    data[\"provider\"] = this.provider;\n    super.toJSON(data);\n    return data;\n  }\n\n}\nexport class LoginCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.email = _data[\"email\"];\n      this.password = _data[\"password\"];\n      this.clientUri = _data[\"clientUri\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, LoginCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"email\"] = this.email;\n    data[\"password\"] = this.password;\n    data[\"clientUri\"] = this.clientUri;\n    return data;\n  }\n\n}\nexport class ExternalLoginCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.provider = _data[\"provider\"];\n      this.idToken = _data[\"idToken\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, ExternalLoginCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"provider\"] = this.provider;\n    data[\"idToken\"] = this.idToken;\n    return data;\n  }\n\n}\nexport var ExternalAuthProvider = /*#__PURE__*/(() => {\n  (function (ExternalAuthProvider) {\n    ExternalAuthProvider[ExternalAuthProvider[\"Google\"] = 0] = \"Google\";\n    ExternalAuthProvider[ExternalAuthProvider[\"Facebook\"] = 1] = \"Facebook\";\n  })(ExternalAuthProvider || (ExternalAuthProvider = {}));\n\n  return ExternalAuthProvider;\n})();\nexport class ForgotPasswordCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.email = _data[\"email\"];\n      this.clientUri = _data[\"clientUri\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, ForgotPasswordCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"email\"] = this.email;\n    data[\"clientUri\"] = this.clientUri;\n    return data;\n  }\n\n}\nexport class ResetPasswordCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.email = _data[\"email\"];\n      this.password = _data[\"password\"];\n      this.token = _data[\"token\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, ResetPasswordCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"email\"] = this.email;\n    data[\"password\"] = this.password;\n    data[\"token\"] = this.token;\n    return data;\n  }\n\n}\nexport class TokenResponse extends ResponseBase {\n  constructor(data) {\n    super(data);\n  }\n\n  init(_data, _mappings) {\n    super.init(_data);\n\n    if (_data) {\n      this.isSuccessful = _data[\"isSuccessful\"];\n      this.token = _data[\"token\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, TokenResponse);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"isSuccessful\"] = this.isSuccessful;\n    data[\"token\"] = this.token;\n    super.toJSON(data);\n    return data;\n  }\n\n}\nexport class TwoStepVerificationCommand {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n\n  init(_data, _mappings) {\n    if (_data) {\n      this.email = _data[\"email\"];\n      this.token = _data[\"token\"];\n      this.provider = _data[\"provider\"];\n    }\n  }\n\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, TwoStepVerificationCommand);\n  }\n\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"email\"] = this.email;\n    data[\"token\"] = this.token;\n    data[\"provider\"] = this.provider;\n    return data;\n  }\n\n}\n\nfunction jsonParse(json, reviver) {\n  json = JSON.parse(json, reviver);\n  var byid = {};\n  var refs = [];\n\n  json = function recurse(obj, prop, parent) {\n    if (typeof obj !== 'object' || !obj) return obj;\n\n    if (\"$ref\" in obj) {\n      let ref = obj.$ref;\n      if (ref in byid) return byid[ref];\n      refs.push([parent, prop, ref]);\n      return undefined;\n    } else if (\"$id\" in obj) {\n      let id = obj.$id;\n      delete obj.$id;\n      if (\"$values\" in obj) obj = obj.$values;\n      byid[id] = obj;\n    }\n\n    if (Array.isArray(obj)) {\n      obj = obj.map((v, i) => recurse(v, i, obj));\n    } else {\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object') obj[p] = recurse(obj[p], p, obj);\n      }\n    }\n\n    return obj;\n  }(json);\n\n  for (let i = 0; i < refs.length; i++) {\n    const ref = refs[i];\n    ref[0][ref[1]] = byid[ref[2]];\n  }\n\n  return json;\n}\n\nfunction createInstance(data, mappings, type) {\n  if (!mappings) mappings = [];\n  if (!data) return null;\n  const mappingIndexName = \"__mappingIndex\";\n  if (data[mappingIndexName]) return mappings[data[mappingIndexName]].target;\n  data[mappingIndexName] = mappings.length;\n  let result = new type();\n  mappings.push({\n    source: data,\n    target: result\n  });\n  result.init(data, mappings);\n  return result;\n}\n\nexport class ApiException extends Error {\n  constructor(message, status, response, headers, result) {\n    super();\n    this.isApiException = true;\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n\n  static isApiException(obj) {\n    return obj.isApiException === true;\n  }\n\n}\n\nfunction throwException(message, status, response, headers, result) {\n  if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new ApiException(message, status, response, headers, null));\n}\n\nfunction blobToText(blob) {\n  return new Observable(observer => {\n    if (!blob) {\n      observer.next(\"\");\n      observer.complete();\n    } else {\n      let reader = new FileReader();\n\n      reader.onload = event => {\n        observer.next(event.target.result);\n        observer.complete();\n      };\n\n      reader.readAsText(blob);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}