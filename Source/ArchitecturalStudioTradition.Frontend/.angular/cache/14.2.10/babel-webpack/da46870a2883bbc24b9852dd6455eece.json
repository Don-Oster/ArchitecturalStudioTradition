{"ast":null,"code":"import _defineProperty from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toArray from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _createForOfIteratorHelper from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _get from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Work/Projects/ArchitecturalStudioTradition/Source/ArchitecturalStudioTradition.Frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nvar DefaultLoader = /*#__PURE__*/function () {\n  function DefaultLoader(translations) {\n    _classCallCheck(this, DefaultLoader);\n\n    this.translations = translations;\n  }\n\n  _createClass(DefaultLoader, [{\n    key: \"getTranslation\",\n    value: function getTranslation(lang) {\n      return of(this.translations.get(lang) || {});\n    }\n  }]);\n\n  return DefaultLoader;\n}();\n\nvar TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n\n\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n\n  return path.split('.').reduce(function (p, c) {\n    return p === null || p === void 0 ? void 0 : p[c];\n  }, obj);\n}\n\nfunction setValue(obj, prop, val) {\n  obj = Object.assign({}, obj);\n  var split = prop.split('.');\n  var lastIndex = split.length - 1;\n  split.reduce(function (acc, part, index) {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\n\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return collection ? collection.length : 0;\n}\n\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (word, index) {\n    return index == 0 ? word.toLowerCase() : word.toUpperCase();\n  }).replace(/\\s+|_|-|\\//g, '');\n}\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\n\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\n\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\n\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\n\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\n\nvar TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: function factory() {\n    return {\n      defaultLang: 'en'\n    };\n  }\n});\nvar defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\n\nfunction translocoConfig() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n  return Object.assign(Object.assign({}, defaultConfig), config);\n}\n\nvar TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nvar DefaultTranspiler = /*#__PURE__*/(function () {\n  var DefaultTranspiler = /*#__PURE__*/function () {\n    function DefaultTranspiler(userConfig) {\n      _classCallCheck(this, DefaultTranspiler);\n\n      this.interpolationMatcher = resolveMatcher(userConfig);\n    }\n\n    _createClass(DefaultTranspiler, [{\n      key: \"transpile\",\n      value: function transpile(value) {\n        var _this = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var translation = arguments.length > 2 ? arguments[2] : undefined;\n\n        if (isString(value)) {\n          return value.replace(this.interpolationMatcher, function (_, match) {\n            match = match.trim();\n\n            if (isDefined(params[match])) {\n              return params[match];\n            }\n\n            return isDefined(translation[match]) ? _this.transpile(translation[match], params, translation) : '';\n          });\n        } else if (params) {\n          if (isObject(value)) {\n            value = this.handleObject(value, params, translation);\n          } else if (Array.isArray(value)) {\n            value = this.handleArray(value, params, translation);\n          }\n        }\n\n        return value;\n      }\n      /**\n       *\n       * @example\n       *\n       * const en = {\n       *  a: {\n       *    b: {\n       *      c: \"Hello {{ value }}\"\n       *    }\n       *  }\n       * }\n       *\n       * const params =  {\n       *  \"b.c\": { value: \"Transloco \"}\n       * }\n       *\n       * service.selectTranslate('a', params);\n       *\n       * // the first param will be the result of `en.a`.\n       * // the second param will be `params`.\n       * parser.transpile(value, params, {});\n       *\n       *\n       */\n\n    }, {\n      key: \"handleObject\",\n      value: function handleObject(value) {\n        var _this2 = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var translation = arguments.length > 2 ? arguments[2] : undefined;\n        var result = value;\n        Object.keys(params).forEach(function (p) {\n          // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n          var v = getValue(result, p); // get the params of \"b.c\" => { value: \"Transloco\" }\n\n          var getParams = getValue(params, p); // transpile the value => \"Hello Transloco\"\n\n          var transpiled = _this2.transpile(v, getParams, translation); // set \"b.c\" to `transpiled`\n\n\n          result = setValue(result, p, transpiled);\n        });\n        return result;\n      }\n    }, {\n      key: \"handleArray\",\n      value: function handleArray(value) {\n        var _this3 = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var translation = arguments.length > 2 ? arguments[2] : undefined;\n        return value.map(function (v) {\n          return _this3.transpile(v, params, translation);\n        });\n      }\n    }]);\n\n    return DefaultTranspiler;\n  }();\n\n  DefaultTranspiler.ɵfac = function DefaultTranspiler_Factory(t) {\n    return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n  };\n\n  DefaultTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultTranspiler,\n    factory: DefaultTranspiler.ɵfac\n  });\n  return DefaultTranspiler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction resolveMatcher(userConfig) {\n  var _ref = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation,\n      _ref2 = _slicedToArray(_ref, 2),\n      start = _ref2[0],\n      end = _ref2[1];\n\n  return new RegExp(\"\".concat(start, \"(.*?)\").concat(end), 'g');\n}\n\nfunction getFunctionArgs(argsString) {\n  var splitted = argsString ? argsString.split(',') : [];\n  var args = [];\n\n  for (var i = 0; i < splitted.length; i++) {\n    var value = splitted[i].trim();\n\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n\n    args.push(value);\n  }\n\n  return args;\n}\n\nvar FunctionalTranspiler = /*#__PURE__*/(function () {\n  var FunctionalTranspiler = /*#__PURE__*/function (_DefaultTranspiler) {\n    _inherits(FunctionalTranspiler, _DefaultTranspiler);\n\n    var _super = _createSuper(FunctionalTranspiler);\n\n    function FunctionalTranspiler(injector) {\n      var _this4;\n\n      _classCallCheck(this, FunctionalTranspiler);\n\n      _this4 = _super.call(this);\n      _this4.injector = injector;\n      return _this4;\n    }\n\n    _createClass(FunctionalTranspiler, [{\n      key: \"transpile\",\n      value: function transpile(value) {\n        var _this5 = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var translation = arguments.length > 2 ? arguments[2] : undefined;\n        var transpiled = value;\n\n        if (isString(value)) {\n          transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, function (match, functionName, args) {\n            try {\n              var func = _this5.injector.get(functionName);\n\n              return func.transpile.apply(func, _toConsumableArray(getFunctionArgs(args)));\n            } catch (e) {\n              var message = \"There is an error in: '\".concat(value, \"'. \\n                          Check that the you used the right syntax in your translation and that the implementation of \").concat(functionName, \" is correct.\");\n\n              if (e.message.includes('NullInjectorError')) {\n                message = \"You are using the '\".concat(functionName, \"' function in your translation but no provider was found!\");\n              }\n\n              throw new Error(message);\n            }\n          });\n        }\n\n        return _get(_getPrototypeOf(FunctionalTranspiler.prototype), \"transpile\", this).call(this, transpiled, params, translation);\n      }\n    }]);\n\n    return FunctionalTranspiler;\n  }(DefaultTranspiler);\n\n  FunctionalTranspiler.ɵfac = function FunctionalTranspiler_Factory(t) {\n    return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n  };\n\n  FunctionalTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FunctionalTranspiler,\n    factory: FunctionalTranspiler.ɵfac\n  });\n  return FunctionalTranspiler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nvar DefaultHandler = /*#__PURE__*/(function () {\n  var DefaultHandler = /*#__PURE__*/function () {\n    function DefaultHandler() {\n      _classCallCheck(this, DefaultHandler);\n    }\n\n    _createClass(DefaultHandler, [{\n      key: \"handle\",\n      value: function handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n          var msg = \"Missing translation for '\".concat(key, \"'\");\n          console.warn(\"%c \".concat(msg), 'font-size: 12px; color: red');\n        }\n\n        return key;\n      }\n    }]);\n\n    return DefaultHandler;\n  }();\n\n  DefaultHandler.ɵfac = function DefaultHandler_Factory(t) {\n    return new (t || DefaultHandler)();\n  };\n\n  DefaultHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultHandler,\n    factory: DefaultHandler.ɵfac\n  });\n  return DefaultHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nvar DefaultInterceptor = /*#__PURE__*/(function () {\n  var DefaultInterceptor = /*#__PURE__*/function () {\n    function DefaultInterceptor() {\n      _classCallCheck(this, DefaultInterceptor);\n    }\n\n    _createClass(DefaultInterceptor, [{\n      key: \"preSaveTranslation\",\n      value: function preSaveTranslation(translation) {\n        return translation;\n      }\n    }, {\n      key: \"preSaveTranslationKey\",\n      value: function preSaveTranslationKey(_, value) {\n        return value;\n      }\n    }]);\n\n    return DefaultInterceptor;\n  }();\n\n  DefaultInterceptor.ɵfac = function DefaultInterceptor_Factory(t) {\n    return new (t || DefaultInterceptor)();\n  };\n\n  DefaultInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultInterceptor,\n    factory: DefaultInterceptor.ɵfac\n  });\n  return DefaultInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nvar DefaultFallbackStrategy = /*#__PURE__*/(function () {\n  var DefaultFallbackStrategy = /*#__PURE__*/function () {\n    function DefaultFallbackStrategy(userConfig) {\n      _classCallCheck(this, DefaultFallbackStrategy);\n\n      this.userConfig = userConfig;\n    }\n\n    _createClass(DefaultFallbackStrategy, [{\n      key: \"getNextLangs\",\n      value: function getNextLangs() {\n        var fallbackLang = this.userConfig.fallbackLang;\n\n        if (!fallbackLang) {\n          throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n      }\n    }]);\n\n    return DefaultFallbackStrategy;\n  }();\n\n  DefaultFallbackStrategy.ɵfac = function DefaultFallbackStrategy_Factory(t) {\n    return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n  };\n\n  DefaultFallbackStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultFallbackStrategy,\n    factory: DefaultFallbackStrategy.ɵfac\n  });\n  return DefaultFallbackStrategy;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  return Object.assign(Object.assign(Object.assign({}, defaultConfig), userConfig), {\n    missingHandler: Object.assign(Object.assign({}, defaultConfig.missingHandler), userConfig.missingHandler),\n    flatten: Object.assign(Object.assign({}, defaultConfig.flatten), userConfig.flatten)\n  });\n}\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n\n\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  var split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n\n\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\n\n\nfunction getPipeValue(str, value) {\n  var char = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '|';\n\n  if (isString(str)) {\n    var splitted = str.split(char);\n    var lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nfunction shouldListenToLangChanges(service, lang) {\n  var _getPipeValue = getPipeValue(lang, 'static'),\n      _getPipeValue2 = _slicedToArray(_getPipeValue, 1),\n      hasStatic = _getPipeValue2[0];\n\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  } // We have 'lang|static' so don't listen to lang changes\n\n\n  return false;\n}\n\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? function (source) {\n    return source;\n  } : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce(function (acc, lang) {\n    acc[\"\".concat(scope, \"/\").concat(lang)] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\n\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\n\nfunction resolveLoader(options) {\n  var path = options.path,\n      inlineLoader = options.inlineLoader,\n      mainLoader = options.mainLoader,\n      data = options.data;\n\n  if (inlineLoader) {\n    var pathLoader = inlineLoader[path];\n\n    if (isFunction(pathLoader) === false) {\n      throw \"You're using an inline loader but didn't provide a loader for \".concat(path);\n    }\n\n    return inlineLoader[path]().then(function (res) {\n      return res.default ? res.default : res;\n    });\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders(_ref3) {\n  var mainLoader = _ref3.mainLoader,\n      path = _ref3.path,\n      data = _ref3.data,\n      fallbackPath = _ref3.fallbackPath,\n      inlineLoader = _ref3.inlineLoader;\n  var paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(function (path) {\n    var loader = resolveLoader({\n      path: path,\n      mainLoader: mainLoader,\n      inlineLoader: inlineLoader,\n      data: data\n    });\n    return from(loader).pipe(map(function (translation) {\n      return {\n        translation: translation,\n        lang: path\n      };\n    }));\n  });\n}\n\nvar service;\n\nfunction translate(key) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var lang = arguments.length > 2 ? arguments[2] : undefined;\n  return service.translate(key, params, lang);\n}\n\nfunction translateObject(key) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var lang = arguments.length > 2 ? arguments[2] : undefined;\n  return service.translateObject(key, params, lang);\n}\n\nvar TranslocoService = /*#__PURE__*/(function () {\n  var TranslocoService = /*#__PURE__*/function () {\n    function TranslocoService(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n      var _this6 = this;\n\n      _classCallCheck(this, TranslocoService);\n\n      this.loader = loader;\n      this.parser = parser;\n      this.missingHandler = missingHandler;\n      this.interceptor = interceptor;\n      this.userConfig = userConfig;\n      this.fallbackStrategy = fallbackStrategy;\n      this.subscription = null;\n      this.translations = new Map();\n      this.cache = new Map();\n      this.defaultLang = '';\n      this.availableLangs = [];\n      this.isResolvedMissingOnce = false;\n      this.failedLangs = new Set();\n      this.events = new Subject();\n      this.events$ = this.events.asObservable();\n\n      if (!this.loader) {\n        this.loader = new DefaultLoader(this.translations);\n      }\n\n      service = this;\n      this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n      this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n      this.setFallbackLangForMissingTranslation(this.mergedConfig);\n      this.setDefaultLang(this.mergedConfig.defaultLang);\n      this.lang = new BehaviorSubject(this.getDefaultLang()); // Don't use distinctUntilChanged as we need the ability to update\n      // the value when using setTranslation or setTranslationKeys\n\n      this.langChanges$ = this.lang.asObservable();\n      /**\n       * When we have a failure, we want to define the next language that succeeded as the active\n       */\n\n      this.subscription = this.events$.subscribe(function (e) {\n        if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n          _this6.setActiveLang(e.payload.langName);\n        }\n      });\n    }\n\n    _createClass(TranslocoService, [{\n      key: \"config\",\n      get: function get() {\n        return this.mergedConfig;\n      }\n    }, {\n      key: \"getDefaultLang\",\n      value: function getDefaultLang() {\n        return this.defaultLang;\n      }\n    }, {\n      key: \"setDefaultLang\",\n      value: function setDefaultLang(lang) {\n        this.defaultLang = lang;\n      }\n    }, {\n      key: \"getActiveLang\",\n      value: function getActiveLang() {\n        return this.lang.getValue();\n      }\n    }, {\n      key: \"setActiveLang\",\n      value: function setActiveLang(lang) {\n        var _a, _b;\n\n        this.lang.next(lang);\n        (_b = (_a = this.parser).onLangChanged) === null || _b === void 0 ? void 0 : _b.call(_a, lang);\n        this.events.next({\n          type: 'langChanged',\n          payload: getEventPayload(lang)\n        });\n        return this;\n      }\n    }, {\n      key: \"setAvailableLangs\",\n      value: function setAvailableLangs(langs) {\n        this.availableLangs = langs;\n      }\n      /**\n       * Gets the available languages.\n       *\n       * @returns\n       * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n       * depending on how the available languages are set in your module.\n       */\n\n    }, {\n      key: \"getAvailableLangs\",\n      value: function getAvailableLangs() {\n        return this.availableLangs;\n      }\n    }, {\n      key: \"load\",\n      value: function load(path) {\n        var _this7 = this;\n\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var cached = this.cache.get(path);\n\n        if (cached) {\n          return cached;\n        }\n\n        var loadTranslation;\n\n        var isScope = this._isLangScoped(path);\n\n        var scope;\n\n        if (isScope) {\n          scope = getScopeFromLang(path);\n        }\n\n        var loadersOptions = {\n          path: path,\n          mainLoader: this.loader,\n          inlineLoader: options.inlineLoader,\n          data: isScope ? {\n            scope: scope\n          } : undefined\n        };\n\n        if (this.useFallbackTranslation(path)) {\n          // if the path is scope the fallback should be `scope/fallbackLang`;\n          var fallback = isScope ? \"\".concat(scope, \"/\").concat(this.firstFallbackLang) : this.firstFallbackLang;\n          var loaders = getFallbacksLoaders(Object.assign(Object.assign({}, loadersOptions), {\n            fallbackPath: fallback\n          }));\n          loadTranslation = forkJoin(loaders);\n        } else {\n          var loader = resolveLoader(loadersOptions);\n          loadTranslation = from(loader);\n        }\n\n        var load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(function (translation) {\n          if (Array.isArray(translation)) {\n            translation.forEach(function (t) {\n              _this7.handleSuccess(t.lang, t.translation); // Save the fallback in cache so we'll not create a redundant request\n\n\n              if (t.lang !== path) {\n                _this7.cache.set(t.lang, of({}));\n              }\n            });\n            return;\n          }\n\n          _this7.handleSuccess(path, translation);\n        }), catchError(function (error) {\n          if (!_this7.mergedConfig.prodMode) {\n            console.error(\"Error while trying to load \\\"\".concat(path, \"\\\"\"), error);\n          }\n\n          return _this7.handleFailure(path, options);\n        }), shareReplay(1));\n        this.cache.set(path, load$);\n        return load$;\n      }\n      /**\n       * Gets the instant translated value of a key\n       *\n       * @example\n       *\n       * translate<string>('hello')\n       * translate('hello', { value: 'value' })\n       * translate<string[]>(['hello', 'key'])\n       * translate('hello', { }, 'en')\n       * translate('scope.someKey', { }, 'en')\n       */\n\n    }, {\n      key: \"translate\",\n      value: function translate(key) {\n        var _this8 = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getActiveLang();\n        if (!key) return key;\n\n        var _this$resolveLangAndS = this.resolveLangAndScope(lang),\n            scope = _this$resolveLangAndS.scope,\n            resolveLang = _this$resolveLangAndS.resolveLang;\n\n        if (Array.isArray(key)) {\n          return key.map(function (k) {\n            return _this8.translate(scope ? \"\".concat(scope, \".\").concat(k) : k, params, resolveLang);\n          });\n        }\n\n        key = scope ? \"\".concat(scope, \".\").concat(key) : key;\n        var translation = this.getTranslation(resolveLang);\n        var value = translation[key];\n\n        if (!value) {\n          return this._handleMissingKey(key, value, params);\n        }\n\n        return this.parser.transpile(value, params, translation);\n      }\n      /**\n       * Gets the translated value of a key as observable\n       *\n       * @example\n       *\n       * selectTranslate<string>('hello').subscribe(value => ...)\n       * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n       * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n       * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n       *\n       */\n\n    }, {\n      key: \"selectTranslate\",\n      value: function selectTranslate(key, params, lang) {\n        var _this9 = this;\n\n        var _isObject = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var inlineLoader;\n\n        var load = function load(lang, options) {\n          return _this9.load(lang, options).pipe(map(function () {\n            return _isObject ? _this9.translateObject(key, params, lang) : _this9.translate(key, params, lang);\n          }));\n        };\n\n        if (isNil(lang)) {\n          return this.langChanges$.pipe(switchMap(function (lang) {\n            return load(lang);\n          }));\n        }\n\n        if (isScopeObject(lang)) {\n          // it's a scope object.\n          var providerScope = lang;\n          lang = providerScope.scope;\n          inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n        }\n\n        lang = lang;\n\n        if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n          return load(lang);\n        } // it's a scope\n\n\n        var scope = lang;\n        return this.langChanges$.pipe(switchMap(function (lang) {\n          return load(\"\".concat(scope, \"/\").concat(lang), {\n            inlineLoader: inlineLoader\n          });\n        }));\n      }\n      /**\n       * Whether the scope with lang\n       *\n       * @example\n       *\n       * todos/en => true\n       * todos => false\n       */\n\n    }, {\n      key: \"isScopeWithLang\",\n      value: function isScopeWithLang(lang) {\n        return this.isLang(getLangFromScope(lang));\n      }\n    }, {\n      key: \"translateObject\",\n      value: function translateObject(key) {\n        var _this10 = this;\n\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getActiveLang();\n\n        if (isString(key) || Array.isArray(key)) {\n          var _this$resolveLangAndS2 = this.resolveLangAndScope(lang),\n              resolveLang = _this$resolveLangAndS2.resolveLang,\n              scope = _this$resolveLangAndS2.scope;\n\n          if (Array.isArray(key)) {\n            return key.map(function (k) {\n              return _this10.translateObject(scope ? \"\".concat(scope, \".\").concat(k) : k, params, resolveLang);\n            });\n          }\n\n          var translation = this.getTranslation(resolveLang);\n          key = scope ? \"\".concat(scope, \".\").concat(key) : key;\n          var value = unflatten(this.getObjectByKey(translation, key));\n          /* If an empty object was returned we want to try and translate the key as a string and not an object */\n\n          return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n        }\n\n        var translations = [];\n\n        var _iterator = _createForOfIteratorHelper(this.getEntries(key)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                _key = _step$value[0],\n                _params = _step$value[1];\n\n            translations.push(this.translateObject(_key, _params, lang));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return translations;\n      }\n    }, {\n      key: \"selectTranslateObject\",\n      value: function selectTranslateObject(key, params, lang) {\n        var _this11 = this;\n\n        if (isString(key) || Array.isArray(key)) {\n          return this.selectTranslate(key, params, lang, true);\n        }\n\n        var _this$getEntries = this.getEntries(key),\n            _this$getEntries2 = _toArray(_this$getEntries),\n            _this$getEntries2$ = _slicedToArray(_this$getEntries2[0], 2),\n            firstKey = _this$getEntries2$[0],\n            firstParams = _this$getEntries2$[1],\n            rest = _this$getEntries2.slice(1);\n        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n\n\n        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(function (value) {\n          var translations = [value];\n\n          var _iterator2 = _createForOfIteratorHelper(rest),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  _key = _step2$value[0],\n                  _params = _step2$value[1];\n\n              translations.push(_this11.translateObject(_key, _params, lang));\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          return translations;\n        }));\n      }\n    }, {\n      key: \"getTranslation\",\n      value: function getTranslation(langOrScope) {\n        if (langOrScope) {\n          if (this.isLang(langOrScope)) {\n            return this.translations.get(langOrScope) || {};\n          } else {\n            // This is a scope, build the scope value from the translation object\n            var _this$resolveLangAndS3 = this.resolveLangAndScope(langOrScope),\n                scope = _this$resolveLangAndS3.scope,\n                resolveLang = _this$resolveLangAndS3.resolveLang;\n\n            var translation = this.translations.get(resolveLang) || {};\n            return this.getObjectByKey(translation, scope);\n          }\n        }\n\n        return this.translations;\n      }\n      /**\n       * Gets an object of translations for a given language\n       *\n       * @example\n       *\n       * selectTranslation().subscribe() - will return the current lang translation\n       * selectTranslation('es').subscribe()\n       * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n       * selectTranslation('admin-page/es').subscribe()\n       */\n\n    }, {\n      key: \"selectTranslation\",\n      value: function selectTranslation(lang) {\n        var _this12 = this;\n\n        var language$ = this.langChanges$;\n\n        if (lang) {\n          var scopeLangSpecified = getLangFromScope(lang) !== lang;\n\n          if (this.isLang(lang) || scopeLangSpecified) {\n            language$ = of(lang);\n          } else {\n            language$ = this.langChanges$.pipe(map(function (currentLang) {\n              return \"\".concat(lang, \"/\").concat(currentLang);\n            }));\n          }\n        }\n\n        return language$.pipe(switchMap(function (language) {\n          return _this12.load(language).pipe(map(function () {\n            return _this12.getTranslation(language);\n          }));\n        }));\n      }\n      /**\n       * Sets or merge a given translation object to current lang\n       *\n       * @example\n       *\n       * setTranslation({ ... })\n       * setTranslation({ ... }, 'en')\n       * setTranslation({ ... }, 'es', { merge: false } )\n       * setTranslation({ ... }, 'todos/en', { merge: false } )\n       */\n\n    }, {\n      key: \"setTranslation\",\n      value: function setTranslation(translation) {\n        var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveLang();\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var defaults = {\n          merge: true,\n          emitChange: true\n        };\n        var mergedOptions = Object.assign(Object.assign({}, defaults), options);\n        var scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         */\n\n        var flattenScopeOrTranslation = translation; // Merged the scoped language into the active language\n\n        if (scope) {\n          var key = this.getMappedScope(scope);\n          flattenScopeOrTranslation = flatten(_defineProperty({}, key, translation));\n        }\n\n        var currentLang = scope ? getLangFromScope(lang) : lang;\n        var mergedTranslation = Object.assign(Object.assign({}, mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);\n        var flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n        var withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n      }\n      /**\n       * Sets translation key with given value\n       *\n       * @example\n       *\n       * setTranslationKey('key', 'value')\n       * setTranslationKey('key.nested', 'value')\n       * setTranslationKey('key.nested', 'value', 'en')\n       * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n       */\n\n    }, {\n      key: \"setTranslationKey\",\n      value: function setTranslationKey(key, value) {\n        var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getActiveLang();\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n\n        var newValue = _defineProperty({}, key, withHook);\n\n        this.setTranslation(newValue, lang, Object.assign(Object.assign({}, options), {\n          merge: true\n        }));\n      }\n      /**\n       * Sets the fallback lang for the currently active language\n       * @param fallbackLang\n       */\n\n    }, {\n      key: \"setFallbackLangForMissingTranslation\",\n      value: function setFallbackLangForMissingTranslation(_ref4) {\n        var fallbackLang = _ref4.fallbackLang;\n        var lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n\n        if (fallbackLang && this.useFallbackTranslation(lang)) {\n          this.firstFallbackLang = lang;\n        }\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"_handleMissingKey\",\n      value: function _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n          return '';\n        }\n\n        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n          // We need to set it to true to prevent a loop\n          this.isResolvedMissingOnce = true;\n          var fallbackValue = this.translate(key, params, this.firstFallbackLang);\n          this.isResolvedMissingOnce = false;\n          return fallbackValue;\n        }\n\n        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"_isLangScoped\",\n      value: function _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n      }\n      /**\n       * Checks if a given string is one of the specified available languages.\n       * @returns\n       * True if the given string is an available language.\n       * False if the given string is not an available language.\n       */\n\n    }, {\n      key: \"isLang\",\n      value: function isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n      }\n      /**\n       * @internal\n       *\n       * We always want to make sure the global lang is loaded\n       * before loading the scope since you can access both via the pipe/directive.\n       */\n\n    }, {\n      key: \"_loadDependencies\",\n      value: function _loadDependencies(path, inlineLoader) {\n        var mainLang = getLangFromScope(path);\n\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n          return combineLatest(this.load(mainLang), this.load(path, {\n            inlineLoader: inlineLoader\n          }));\n        }\n\n        return this.load(path, {\n          inlineLoader: inlineLoader\n        });\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"_completeScopeWithLang\",\n      value: function _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n          return \"\".concat(langOrScope, \"/\").concat(this.getActiveLang());\n        }\n\n        return langOrScope;\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"_setScopeAlias\",\n      value: function _setScopeAlias(scope, alias) {\n        if (!this.mergedConfig.scopeMapping) {\n          this.mergedConfig.scopeMapping = {};\n        }\n\n        this.mergedConfig.scopeMapping[scope] = alias;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.subscription) {\n          this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n          // callback within its `destination` property, preventing classes from being GC'd.\n\n          this.subscription = null;\n        } // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n        // and destroyed per each HTTP request, but any service is not getting GC'd.\n\n\n        this.cache.clear();\n      }\n    }, {\n      key: \"isLoadedTranslation\",\n      value: function isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n      }\n    }, {\n      key: \"getAvailableLangsIds\",\n      value: function getAvailableLangsIds() {\n        var first = this.getAvailableLangs()[0];\n\n        if (isString(first)) {\n          return this.getAvailableLangs();\n        }\n\n        return this.getAvailableLangs().map(function (l) {\n          return l.id;\n        });\n      }\n    }, {\n      key: \"getMissingHandlerData\",\n      value: function getMissingHandlerData() {\n        return Object.assign(Object.assign({}, this.config), {\n          activeLang: this.getActiveLang(),\n          availableLangs: this.availableLangs,\n          defaultLang: this.defaultLang\n        });\n      }\n      /**\n       * Use a fallback translation set for missing keys of the primary language\n       * This is unrelated to the fallback language (which changes the active language)\n       */\n\n    }, {\n      key: \"useFallbackTranslation\",\n      value: function useFallbackTranslation(lang) {\n        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n      }\n    }, {\n      key: \"handleSuccess\",\n      value: function handleSuccess(lang, translation) {\n        var _this13 = this;\n\n        this.setTranslation(translation, lang, {\n          emitChange: false\n        });\n        this.events.next({\n          wasFailure: !!this.failedLangs.size,\n          type: 'translationLoadSuccess',\n          payload: getEventPayload(lang)\n        });\n        this.failedLangs.forEach(function (l) {\n          return _this13.cache.delete(l);\n        });\n        this.failedLangs.clear();\n      }\n    }, {\n      key: \"handleFailure\",\n      value: function handleFailure(lang, loadOptions) {\n        // When starting to load a first choice language, initialize\n        // the failed counter and resolve the fallback langs.\n        if (isNil(loadOptions.failedCounter)) {\n          loadOptions.failedCounter = 0;\n\n          if (!loadOptions.fallbackLangs) {\n            loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n          }\n        }\n\n        var splitted = lang.split('/');\n        var fallbacks = loadOptions.fallbackLangs;\n        var nextLang = fallbacks[loadOptions.failedCounter];\n        this.failedLangs.add(lang); // This handles the case where a loaded fallback language is requested again\n\n        if (this.cache.has(nextLang)) {\n          this.handleSuccess(nextLang, this.getTranslation(nextLang));\n          return EMPTY;\n        }\n\n        var isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n        if (!nextLang || isFallbackLang) {\n          var msg = \"Unable to load translation and all the fallback languages\";\n\n          if (splitted.length > 1) {\n            msg += \", did you misspelled the scope name?\";\n          }\n\n          throw new Error(msg);\n        }\n\n        var resolveLang = nextLang; // if it's scoped lang\n\n        if (splitted.length > 1) {\n          // We need to resolve it to:\n          // todos/langNotExists => todos/nextLang\n          splitted[splitted.length - 1] = nextLang;\n          resolveLang = splitted.join('/');\n        }\n\n        loadOptions.failedCounter++;\n        this.events.next({\n          type: 'translationLoadFailure',\n          payload: getEventPayload(lang)\n        });\n        return this.load(resolveLang, loadOptions);\n      }\n    }, {\n      key: \"getMappedScope\",\n      value: function getMappedScope(scope) {\n        var _this$config$scopeMap = this.config.scopeMapping,\n            scopeMapping = _this$config$scopeMap === void 0 ? {} : _this$config$scopeMap;\n        return scopeMapping[scope] || toCamelCase(scope);\n      }\n      /**\n       * If lang is scope we need to check the following cases:\n       * todos/es => in this case we should take `es` as lang\n       * todos => in this case we should set the active lang as lang\n       */\n\n    }, {\n      key: \"resolveLangAndScope\",\n      value: function resolveLangAndScope(lang) {\n        var resolveLang = lang;\n        var scope;\n\n        if (this._isLangScoped(lang)) {\n          // en for example\n          var langFromScope = getLangFromScope(lang); // en is lang\n\n          var hasLang = this.isLang(langFromScope); // take en\n\n          resolveLang = hasLang ? langFromScope : this.getActiveLang(); // find the scope\n\n          scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n\n        return {\n          scope: scope,\n          resolveLang: resolveLang\n        };\n      }\n    }, {\n      key: \"getObjectByKey\",\n      value: function getObjectByKey(translation, key) {\n        var result = {};\n        var prefix = \"\".concat(key, \".\");\n\n        for (var currentKey in translation) {\n          if (currentKey.startsWith(prefix)) {\n            result[currentKey.replace(prefix, '')] = translation[currentKey];\n          }\n        }\n\n        return result;\n      }\n    }, {\n      key: \"getEntries\",\n      value: function getEntries(key) {\n        return key instanceof Map ? key.entries() : Object.entries(key);\n      }\n    }]);\n\n    return TranslocoService;\n  }();\n\n  TranslocoService.ɵfac = function TranslocoService_Factory(t) {\n    return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n  };\n\n  TranslocoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TranslocoService,\n    factory: TranslocoService.ɵfac,\n    providedIn: 'root'\n  });\n  return TranslocoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TranslocoLoaderComponent = /*#__PURE__*/(function () {\n  var TranslocoLoaderComponent = /*#__PURE__*/_createClass(function TranslocoLoaderComponent() {\n    _classCallCheck(this, TranslocoLoaderComponent);\n  });\n\n  TranslocoLoaderComponent.ɵfac = function TranslocoLoaderComponent_Factory(t) {\n    return new (t || TranslocoLoaderComponent)();\n  };\n\n  TranslocoLoaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TranslocoLoaderComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      html: \"html\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n    template: function TranslocoLoaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  return TranslocoLoaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TemplateHandler = /*#__PURE__*/function () {\n  function TemplateHandler(view, vcr) {\n    _classCallCheck(this, TemplateHandler);\n\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n\n  _createClass(TemplateHandler, [{\n    key: \"attachView\",\n    value: function attachView() {\n      if (this.view instanceof TemplateRef) {\n        this.vcr.createEmbeddedView(this.view);\n      } else if (isString(this.view)) {\n        var componentRef = this.createComponent(TranslocoLoaderComponent);\n        componentRef.instance.html = this.view;\n        componentRef.hostView.detectChanges();\n      } else {\n        this.createComponent(this.view);\n      }\n    }\n  }, {\n    key: \"detachView\",\n    value: function detachView() {\n      this.vcr.clear();\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(cmp) {\n      var cfr = this.injector.get(ComponentFactoryResolver);\n      var factory = cfr.resolveComponentFactory(cmp);\n      return this.vcr.createComponent(factory);\n    }\n  }]);\n\n  return TemplateHandler;\n}();\n\nvar TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nvar TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nvar TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nvar LangResolver = /*#__PURE__*/function () {\n  function LangResolver() {\n    _classCallCheck(this, LangResolver);\n\n    this.initialized = false;\n  } // inline => provider => active\n\n\n  _createClass(LangResolver, [{\n    key: \"resolve\",\n    value: function resolve(_ref5) {\n      var inline = _ref5.inline,\n          provider = _ref5.provider,\n          active = _ref5.active;\n      var lang = active;\n      /**\n       * When the user changes the lang we need to update\n       * the view. Otherwise, the lang will remain the inline/provided lang\n       */\n\n      if (this.initialized) {\n        lang = active;\n        return lang;\n      }\n\n      if (provider) {\n        var _getPipeValue3 = getPipeValue(provider, 'static'),\n            _getPipeValue4 = _slicedToArray(_getPipeValue3, 2),\n            extracted = _getPipeValue4[1];\n\n        lang = extracted;\n      }\n\n      if (inline) {\n        var _getPipeValue5 = getPipeValue(inline, 'static'),\n            _getPipeValue6 = _slicedToArray(_getPipeValue5, 2),\n            _extracted = _getPipeValue6[1];\n\n        lang = _extracted;\n      }\n\n      this.initialized = true;\n      return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * @example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     */\n\n  }, {\n    key: \"resolveLangBasedOnScope\",\n    value: function resolveLangBasedOnScope(lang) {\n      var scope = getScopeFromLang(lang);\n      return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * @example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     */\n\n  }, {\n    key: \"resolveLangPath\",\n    value: function resolveLangPath(lang, scope) {\n      return scope ? \"\".concat(scope, \"/\").concat(lang) : lang;\n    }\n  }]);\n\n  return LangResolver;\n}();\n\nvar ScopeResolver = /*#__PURE__*/function () {\n  function ScopeResolver(translocoService) {\n    _classCallCheck(this, ScopeResolver);\n\n    this.translocoService = translocoService;\n  } // inline => provider\n\n\n  _createClass(ScopeResolver, [{\n    key: \"resolve\",\n    value: function resolve() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        inline: undefined,\n        provider: undefined\n      },\n          inline = _ref6.inline,\n          provider = _ref6.provider;\n\n      if (inline) {\n        return inline;\n      }\n\n      if (provider) {\n        if (isScopeObject(provider)) {\n          var scope = provider.scope,\n              _provider$alias = provider.alias,\n              alias = _provider$alias === void 0 ? toCamelCase(scope) : _provider$alias;\n\n          this.translocoService._setScopeAlias(scope, alias);\n\n          return scope;\n        }\n\n        return provider;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return ScopeResolver;\n}();\n\nvar TranslocoDirective = /*#__PURE__*/(function () {\n  var TranslocoDirective = /*#__PURE__*/function () {\n    function TranslocoDirective(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n      _classCallCheck(this, TranslocoDirective);\n\n      this.translocoService = translocoService;\n      this.tpl = tpl;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.providedLoadingTpl = providedLoadingTpl;\n      this.vcr = vcr;\n      this.cdr = cdr;\n      this.host = host;\n      this.renderer = renderer;\n      this.subscription = null;\n      this.translationMemo = {};\n      this.params = {}; // Whether we already rendered the view once\n\n      this.initialized = false;\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n      this.strategy = this.tpl === null ? 'attribute' : 'structural';\n    }\n\n    _createClass(TranslocoDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this14 = this;\n\n        var listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n        this.subscription = this.translocoService.langChanges$.pipe(switchMap(function (activeLang) {\n          var lang = _this14.langResolver.resolve({\n            inline: _this14.inlineLang,\n            provider: _this14.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(_this14.providerScope) ? forkJoin(_this14.providerScope.map(function (providerScope) {\n            return _this14.resolveScope(lang, providerScope);\n          })) : _this14.resolveScope(lang, _this14.providerScope);\n        }), listenOrNotOperator(listenToLangChange)).subscribe(function () {\n          _this14.currentLang = _this14.langResolver.resolveLangBasedOnScope(_this14.path);\n          _this14.strategy === 'attribute' ? _this14.attributeStrategy() : _this14.structuralStrategy(_this14.currentLang, _this14.inlineRead);\n\n          _this14.cdr.markForCheck();\n\n          _this14.initialized = true;\n        });\n        var loadingTpl = this.getLoadingTpl();\n\n        if (!this.initialized && loadingTpl) {\n          this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n          this.loaderTplHandler.attachView();\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        if (this.strategy === 'attribute') {\n          var notInit = Object.keys(changes).some(function (v) {\n            return !changes[v].firstChange;\n          });\n          notInit && this.attributeStrategy();\n        }\n      }\n    }, {\n      key: \"attributeStrategy\",\n      value: function attributeStrategy() {\n        this.detachLoader();\n        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n      }\n    }, {\n      key: \"structuralStrategy\",\n      value: function structuralStrategy(lang, read) {\n        this.translationMemo = {};\n\n        if (this.view) {\n          // when the lang changes we need to change the reference so Angular will update the view\n          this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n          this.view.context['currentLang'] = this.currentLang;\n        } else {\n          this.detachLoader();\n          this.view = this.vcr.createEmbeddedView(this.tpl, {\n            $implicit: this.getTranslateFn(lang, read),\n            currentLang: this.currentLang\n          });\n        }\n      }\n    }, {\n      key: \"getTranslateFn\",\n      value: function getTranslateFn(lang, read) {\n        var _this15 = this;\n\n        return function (key, params) {\n          var withRead = read ? \"\".concat(read, \".\").concat(key) : key;\n          var withParams = params ? \"\".concat(withRead).concat(JSON.stringify(params)) : withRead;\n\n          if (Object.prototype.hasOwnProperty.call(_this15.translationMemo, withParams)) {\n            return _this15.translationMemo[withParams].value;\n          }\n\n          _this15.translationMemo[withParams] = {\n            params: params,\n            value: _this15.translocoService.translate(withRead, params, lang)\n          };\n          return _this15.translationMemo[withParams].value;\n        };\n      }\n    }, {\n      key: \"getLoadingTpl\",\n      value: function getLoadingTpl() {\n        return this.inlineTpl || this.providedLoadingTpl;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.subscription) {\n          this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n          // callback within its `destination` property, preventing classes from being GC'd.\n\n          this.subscription = null;\n        }\n      }\n    }, {\n      key: \"detachLoader\",\n      value: function detachLoader() {\n        var _a;\n\n        (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();\n      }\n    }, {\n      key: \"resolveScope\",\n      value: function resolveScope(lang, providerScope) {\n        var resolvedScope = this.scopeResolver.resolve({\n          inline: this.inlineScope,\n          provider: providerScope\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        var inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n      }\n    }], [{\n      key: \"ngTemplateContextGuard\",\n      value: function ngTemplateContextGuard(dir, ctx) {\n        return true;\n      }\n    }]);\n\n    return TranslocoDirective;\n  }();\n\n  TranslocoDirective.ɵfac = function TranslocoDirective_Factory(t) {\n    return new (t || TranslocoDirective)(i0.ɵɵdirectiveInject(TranslocoService), i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  TranslocoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TranslocoDirective,\n    selectors: [[\"\", \"transloco\", \"\"]],\n    inputs: {\n      key: [\"transloco\", \"key\"],\n      params: [\"translocoParams\", \"params\"],\n      inlineScope: [\"translocoScope\", \"inlineScope\"],\n      inlineRead: [\"translocoRead\", \"inlineRead\"],\n      inlineLang: [\"translocoLang\", \"inlineLang\"],\n      inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TranslocoDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TranslocoPipe = /*#__PURE__*/(function () {\n  var TranslocoPipe = /*#__PURE__*/function () {\n    function TranslocoPipe(translocoService, providerScope, providerLang, cdr) {\n      _classCallCheck(this, TranslocoPipe);\n\n      this.translocoService = translocoService;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.cdr = cdr;\n      this.subscription = null;\n      this.lastValue = '';\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n    } // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n\n\n    _createClass(TranslocoPipe, [{\n      key: \"transform\",\n      value: function transform(key, params, inlineLang) {\n        var _this16 = this;\n\n        var _a;\n\n        if (!key) {\n          return key;\n        }\n\n        var keyName = params ? \"\".concat(key).concat(JSON.stringify(params)) : key;\n\n        if (keyName === this.lastKey) {\n          return this.lastValue;\n        }\n\n        this.lastKey = keyName;\n        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        var listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n        this.subscription = this.translocoService.langChanges$.pipe(switchMap(function (activeLang) {\n          var lang = _this16.langResolver.resolve({\n            inline: inlineLang,\n            provider: _this16.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(_this16.providerScope) ? forkJoin(_this16.providerScope.map(function (providerScope) {\n            return _this16.resolveScope(lang, providerScope);\n          })) : _this16.resolveScope(lang, _this16.providerScope);\n        }), listenOrNotOperator(listenToLangChange)).subscribe(function () {\n          return _this16.updateValue(key, params);\n        });\n        return this.lastValue;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.subscription) {\n          this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n          // callback within its `destination` property, preventing classes from being GC'd.\n\n          this.subscription = null;\n        }\n      }\n    }, {\n      key: \"updateValue\",\n      value: function updateValue(key, params) {\n        var lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.translocoService.translate(key, params, lang);\n        this.cdr.markForCheck();\n      }\n    }, {\n      key: \"resolveScope\",\n      value: function resolveScope(lang, providerScope) {\n        var resolvedScope = this.scopeResolver.resolve({\n          inline: undefined,\n          provider: providerScope\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        var inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n      }\n    }]);\n\n    return TranslocoPipe;\n  }();\n\n  TranslocoPipe.ɵfac = function TranslocoPipe_Factory(t) {\n    return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  };\n\n  TranslocoPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"transloco\",\n    type: TranslocoPipe,\n    pure: false\n  });\n  return TranslocoPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\nvar TranslocoModule = /*#__PURE__*/(function () {\n  var TranslocoModule = /*#__PURE__*/_createClass(function TranslocoModule() {\n    _classCallCheck(this, TranslocoModule);\n  });\n\n  TranslocoModule.ɵfac = function TranslocoModule_Factory(t) {\n    return new (t || TranslocoModule)();\n  };\n\n  TranslocoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoModule\n  });\n  TranslocoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [defaultProviders]\n  });\n  return TranslocoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nvar TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nvar TestingLoader = /*#__PURE__*/(function () {\n  var TestingLoader = /*#__PURE__*/function () {\n    function TestingLoader(langs) {\n      _classCallCheck(this, TestingLoader);\n\n      this.langs = langs;\n    }\n\n    _createClass(TestingLoader, [{\n      key: \"getTranslation\",\n      value: function getTranslation(lang) {\n        return of(this.langs[lang]);\n      }\n    }]);\n\n    return TestingLoader;\n  }();\n\n  TestingLoader.ɵfac = function TestingLoader_Factory(t) {\n    return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n  };\n\n  TestingLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TestingLoader,\n    factory: TestingLoader.ɵfac\n  });\n  return TestingLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction initTranslocoService(service) {\n  var langs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n\n  var preloadAllLangs = function preloadAllLangs() {\n    return options.preloadLangs ? Promise.all(Object.keys(langs).map(function (lang) {\n      return service.load(lang).toPromise();\n    })) : Promise.resolve();\n  };\n\n  return preloadAllLangs;\n}\n\nvar TranslocoTestingModule = /*#__PURE__*/(function () {\n  var TranslocoTestingModule = /*#__PURE__*/function () {\n    function TranslocoTestingModule() {\n      _classCallCheck(this, TranslocoTestingModule);\n    }\n\n    _createClass(TranslocoTestingModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(options) {\n        return {\n          ngModule: TranslocoTestingModule,\n          providers: [{\n            provide: TRANSLOCO_TEST_LANGS,\n            useValue: options.langs\n          }, {\n            provide: TRANSLOCO_TEST_OPTIONS,\n            useValue: options\n          }, {\n            provide: APP_INITIALIZER,\n            useFactory: initTranslocoService,\n            deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n            multi: true\n          }, {\n            provide: TRANSLOCO_LOADER,\n            useClass: TestingLoader\n          }, defaultProviders, {\n            provide: TRANSLOCO_CONFIG,\n            useValue: translocoConfig(Object.assign({\n              prodMode: true,\n              missingHandler: {\n                logMissingKey: false\n              }\n            }, options.translocoConfig))\n          }]\n        };\n      }\n    }]);\n\n    return TranslocoTestingModule;\n  }();\n\n  TranslocoTestingModule.ɵfac = function TranslocoTestingModule_Factory(t) {\n    return new (t || TranslocoTestingModule)();\n  };\n\n  TranslocoTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoTestingModule\n  });\n  TranslocoTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TranslocoModule]\n  });\n  return TranslocoTestingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\n\n\nfunction getBrowserLang() {\n  var browserLang = getBrowserCultureLang();\n\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\n\n\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n\n  var navigator = window.navigator;\n  var browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten }; //# sourceMappingURL=ngneat-transloco.mjs.map","map":null,"metadata":{},"sourceType":"module"}